/**
 * PANDA 3D SOFTWARE
 * Copyright (c) Carnegie Mellon University.  All rights reserved.
 *
 * All use of this software is subject to the terms of the revised BSD
 * license.  You should have received a copy of this license along
 * with this source code in a file named "LICENSE."
 *
 * @file shaderModuleSpirV.cxx
 * @author rdb
 * @date 2019-07-15
 */

#include "shaderModuleSpirV.h"
#include "string_utils.h"
#include "shaderType.h"

//#include <glslang/SPIRV/disassemble.h>

TypeHandle ShaderModuleSpirV::_type_handle;

/**
 * Takes a stream of SPIR-V instructions, and processes it as follows:
 * - All the definitions are parsed out (requires debug info present)
 * - Makes sure that all the inputs have location indices assigned.
 * - Builds up the lists of inputs, outputs and parameters.
 * - Strips debugging information from the module.
 */
ShaderModuleSpirV::
ShaderModuleSpirV(Stage stage, std::vector<uint32_t> words) :
  ShaderModule(stage),
  _instructions(std::move(words))
{
  if (!_instructions.validate_header()) {
    return;
  }

  Definitions defs(_instructions.get_id_bound());
  for (Instruction op : _instructions) {
    if (!parse_instruction(defs, op.opcode, op.args, op.nargs)) {
      shader_cat.error()
        << "Failed to parse SPIR-V shader code.\n";
      return;
    }
  }

  // Check if there is a $Global uniform block.  This is generated by the HLSL
  // front-end of glslang.  If so, unwrap it back down to individual uniforms.
  for (uint32_t id = 0; id < defs.size(); ++id) {
    Definition &def = defs[id];
    if (def._dtype == DT_type && def._name == "$Global") {
      flatten_struct(defs, id);
    }
  }

  // Add in location decorations for any inputs that are missing it.
  assign_locations(defs);

  // Identify the inputs, outputs and uniform parameters.
  for (uint32_t id = 0; id < defs.size(); ++id) {
    Definition &def = defs[id];
    if (def._dtype == DT_variable && def._builtin == spv::BuiltInMax) {
      Variable var;
      var.type = def._type;
      var.name = InternalName::make(def._name);
      var._location = def._location;
      //var._id = id;

      if (def._storage_class == spv::StorageClassInput) {
        _inputs.push_back(std::move(var));
      }
      else if (def._storage_class == spv::StorageClassOutput) {
        _outputs.push_back(std::move(var));
      }
      else if (def._storage_class == spv::StorageClassUniformConstant) {
        _parameters.push_back(std::move(var));
      }

      if (def._type->contains_scalar_type(ShaderType::ST_int) ||
          def._type->contains_scalar_type(ShaderType::ST_uint)) {
        _used_caps |= C_integer;
      }
    }
    else if (def._dtype == DT_variable && def._used &&
             def._storage_class == spv::StorageClassInput) {
      // Built-in input variable.
      switch (def._builtin) {
      case spv::BuiltInVertexId:
        _used_caps |= C_vertex_id;
        break;

      case spv::BuiltInInstanceId:
        _used_caps |= C_instance_id;
        break;

      case spv::BuiltInPrimitiveId:
        _used_caps |= C_primitive_id;
        break;

      case spv::BuiltInSampleId:
      case spv::BuiltInSampleMask:
      case spv::BuiltInSamplePosition:
        _used_caps |= C_sample_variables;
        break;

      default:
        break;
      }
    }
  }

  // We no longer need the debugging information, so it can be safely stripped
  // from the module.
  strip();

  //std::vector<uint32_t> words2(_words.begin(), _words.end());
  //spv::Disassemble(std::cerr, words2);
}

ShaderModuleSpirV::
~ShaderModuleSpirV() {
}

/**
 * Required to implement CopyOnWriteObject.
 */
PT(CopyOnWriteObject) ShaderModuleSpirV::
make_cow_copy() {
  return new ShaderModuleSpirV(*this);
}

std::string ShaderModuleSpirV::
get_ir() const {
  return std::string();
}

/**
 * Links the stage with the given previous stage, by matching up its inputs with
 * the outputs of the previous stage and assigning locations.
 */
bool ShaderModuleSpirV::
link_inputs(const ShaderModule *previous) {
  if (!previous->is_of_type(ShaderModuleSpirV::get_class_type())) {
    return false;
  }
  if (previous->get_stage() >= get_stage()) {
    return false;
  }

  pmap<int, int> location_remap;

  ShaderModuleSpirV *spv_prev = (ShaderModuleSpirV *)previous;

  for (const Variable &input : _inputs) {
    int i = spv_prev->find_output(input.name);
    if (i < 0) {
      shader_cat.error()
        << "Input " << *input.name << " in stage " << get_stage()
        << " does not match any output in stage " << previous->get_stage() << "!\n";
      return false;
    }

    const Variable &output = spv_prev->get_output((size_t)i);
    if (!output.has_location()) {
      shader_cat.error()
        << "Output " << *input.name << " in stage " << previous->get_stage()
        << " has no output location!\n";
      return false;
    }

    if (!input.has_location() || output.get_location() != input.get_location()) {
      location_remap[input.get_location()] = output.get_location();
    }
  }

  if (!location_remap.empty()) {
    remap_locations(spv::StorageClassInput, location_remap);
  }
  return true;
}

/**
 * Remaps parameters with a given location to a given other location.  Locations
 * not included in the map remain untouched.
 */
void ShaderModuleSpirV::
remap_parameter_locations(pmap<int, int> &locations) {
  remap_locations(spv::StorageClassUniformConstant, locations);

  // If we extracted out the parameters, replace the locations there as well.
  for (Variable &parameter : _parameters) {
    if (parameter.has_location()) {
      pmap<int, int>::const_iterator it = locations.find(parameter.get_location());
      if (it != locations.end()) {
        parameter._location = it->second;
      }
    }
  }
}

/**
 * Validates the header of the instruction stream.
 */
bool ShaderModuleSpirV::InstructionStream::
validate_header() const {
  if (_words.size() < 5) {
    shader_cat.error()
      << "Invalid SPIR-V file: too short.\n";
    return false;
  }

  // Validate the header.
  const uint32_t *words = (const uint32_t *)&_words[0];
  if (*words++ != spv::MagicNumber) {
    shader_cat.error()
      << "Invalid SPIR-V file: wrong magic number.\n";
    return false;
  }

  return true;
}

/**
 * Parses the instruction with the given SPIR-V opcode and arguments.  Any
 * encountered definitions are stored in the given definitions vector.
 */
bool ShaderModuleSpirV::
parse_instruction(Definitions &defs, spv::Op opcode, const uint32_t *args, size_t nargs) {
  switch (opcode) {
  case spv::OpExtInstImport:
    defs[args[0]].set_ext_inst((const char *)&args[1]);
    break;

  case spv::OpExtInst:
    nassertr(defs[args[2]]._dtype == DT_ext_inst, false);
    if (defs[args[2]]._name == "GLSL.std.450" && args[3] == 2) {
      // We mark the use of the GLSL roundEven() function, which is not
      // supported by HLSL and requires GLSL 1.30.
      _used_caps |= C_round_even;
    }
    break;

  case spv::OpMemoryModel:
    if (args[0] != spv::AddressingModelLogical) {
      shader_cat.error()
        << "Invalid SPIR-V shader: addressing model Logical must be used.\n";
      return false;
    }
    if (args[1] != spv::MemoryModelGLSL450) {
      shader_cat.error()
        << "Invalid SPIR-V shader: memory model GLSL450 must be used.\n";
      return false;
    }
    break;

  case spv::OpEntryPoint:
    /*switch ((spv::ExecutionModel)args[0]) {
    case spv::ExecutionModelVertex:
      _stage = Stage::vertex;
      break;
    case spv::ExecutionModelTessellationControl:
      _stage = Stage::tess_control;
      break;
    case spv::ExecutionModelTessellationEvaluation:
      _stage = Stage::tess_evaluation;
      break;
    case spv::ExecutionModelGeometry:
      _stage = Stage::geometry;
      break;
    case spv::ExecutionModelFragment:
      _stage = Stage::fragment;
      break;
    default:
      break;
    }*/
    break;

  case spv::OpCapability:
    switch ((spv::Capability)args[0]) {
    case spv::CapabilityFloat64:
      _used_caps |= C_double;
      break;

    case spv::CapabilityImageCubeArray:
      _used_caps |= C_cube_map_array;
      break;

    default:
      break;
    }
    break;

  case spv::OpName:
    defs[args[0]].set_name((const char *)&args[1]);
    break;

  case spv::OpMemberName:
    defs[args[0]].set_member_name(args[1], (const char *)&args[2]);
    break;

  case spv::OpTypeVoid:
    defs[args[0]].set_type(nullptr);
    break;

  case spv::OpTypeBool:
    defs[args[0]].set_type(ShaderType::bool_type);
    break;

  case spv::OpTypeInt:
    {
      if (args[2]) {
        defs[args[0]].set_type(ShaderType::int_type);
      } else {
        defs[args[0]].set_type(ShaderType::uint_type);
      }
    }
    break;

  case spv::OpTypeFloat:
    {
      if (nargs >= 2 && args[1] >= 64) {
        defs[args[0]].set_type(ShaderType::double_type);
      } else {
        defs[args[0]].set_type(ShaderType::float_type);
      }
    }
    break;

  case spv::OpTypeVector:
    {
      const ShaderType::Scalar *element_type;
      DCAST_INTO_R(element_type, defs[args[1]]._type, false);
      uint32_t component_count = args[2];
      defs[args[0]].set_type(ShaderType::register_type(
        ShaderType::Vector(element_type->get_scalar_type(), component_count)));
    }
    break;

  case spv::OpTypeMatrix:
    {
      const ShaderType::Vector *column_type;
      DCAST_INTO_R(column_type, defs[args[1]]._type, false);
      uint32_t num_rows = args[2];
      defs[args[0]].set_type(ShaderType::register_type(
        ShaderType::Matrix(column_type->get_scalar_type(), num_rows, column_type->get_num_components())));
    }
    break;

  case spv::OpTypePointer:
    defs[args[0]].set_type_pointer((spv::StorageClass)args[1], defs[args[2]]._type);
    break;

  case spv::OpTypeImage:
    {
      Texture::TextureType texture_type;
      switch ((spv::Dim)args[2]) {
      case spv::Dim1D:
        if (args[4]) {
          texture_type = Texture::TT_1d_texture_array;
        } else {
          texture_type = Texture::TT_1d_texture;
        }
        break;

      case spv::Dim2D:
        if (args[4]) {
          texture_type = Texture::TT_2d_texture_array;
        } else {
          texture_type = Texture::TT_2d_texture;
        }
        break;

      case spv::Dim3D:
        texture_type = Texture::TT_3d_texture;
        break;

      case spv::DimCube:
        if (args[4]) {
          texture_type = Texture::TT_cube_map_array;
        } else {
          texture_type = Texture::TT_cube_map;
        }
        break;

      case spv::DimRect:
        shader_cat.error()
          << "imageRect shader inputs are not supported.\n";
        return false;

      case spv::DimBuffer:
        texture_type = Texture::TT_buffer_texture;
        break;

      case spv::DimSubpassData:
        shader_cat.error()
          << "subpassInput shader inputs are not supported.\n";
        return false;

      default:
        shader_cat.error()
          << "Unknown image dimensionality in OpTypeImage instruction.\n";
        return false;
      }

      ShaderType::Image::Access access = ShaderType::Image::Access::unknown;
      if (nargs > 8) {
        switch ((spv::AccessQualifier)args[8]) {
        case spv::AccessQualifierReadOnly:
          access = ShaderType::Image::Access::read_only;
          break;
        case spv::AccessQualifierWriteOnly:
          access = ShaderType::Image::Access::write_only;
          break;
        case spv::AccessQualifierReadWrite:
          access = ShaderType::Image::Access::read_write;
          break;
        default:
          shader_cat.error()
            << "Invalid access qualifier in OpTypeImage instruction.\n";
          break;
        }
      }

      defs[args[0]].set_type(ShaderType::register_type(
        ShaderType::Image(texture_type, access)));
    }
    break;

  case spv::OpTypeSampler:
    // A sampler that's not bound to a particular image.
    defs[args[0]].set_type(ShaderType::sampler_type);
    break;

  case spv::OpTypeSampledImage:
    if (const ShaderType::Image *image = defs[args[1]]._type->as_image()) {
      defs[args[0]].set_type(ShaderType::register_type(
        ShaderType::SampledImage(image->get_texture_type())));
    } else {
      shader_cat.error()
        << "OpTypeSampledImage must refer to an image type!\n";
      return false;
    }
    break;

  case spv::OpTypeArray:
    if (defs[args[1]]._type != nullptr) {
      defs[args[0]].set_type(ShaderType::register_type(
        ShaderType::Array(defs[args[1]]._type, defs[args[2]]._constant)));
    }
    break;

  case spv::OpTypeStruct:
    {
      ShaderType::Struct type;
      for (size_t i = 0; i < nargs - 1; ++i) {
        type.add_member(
          defs[args[i + 1]]._type,
          defs[args[0]]._member_names[i]
        );
      }
      defs[args[0]].set_type(ShaderType::register_type(std::move(type)));
    }
    break;

  case spv::OpConstant:
    defs[args[1]].set_constant(defs[args[0]]._type, args + 2, nargs - 2);
    break;

  case spv::OpFunctionCall:
    // Mark all arguments as used.
    for (size_t i = 3; i < nargs; ++i) {
      defs[args[i]].mark_used();
    }
    break;

  case spv::OpVariable:
    {
      const Definition &ptr = defs[args[0]];
      if (ptr._dtype != DT_type_pointer) {
        shader_cat.error()
          << "Variable with id " << args[1] << " should use pointer type\n";
        return false;
      }
      defs[args[1]].set_variable(ptr._type, (spv::StorageClass)args[2]);
    }
    break;

  case spv::OpImageTexelPointer:
  case spv::OpLoad:
  case spv::OpAccessChain:
  case spv::OpInBoundsAccessChain:
  case spv::OpPtrAccessChain:
  case spv::OpCopyObject:
  case spv::OpAtomicLoad:
  case spv::OpAtomicExchange:
  case spv::OpAtomicCompareExchange:
  case spv::OpAtomicCompareExchangeWeak:
  case spv::OpAtomicIIncrement:
  case spv::OpAtomicIDecrement:
  case spv::OpAtomicIAdd:
  case spv::OpAtomicISub:
  case spv::OpAtomicSMin:
  case spv::OpAtomicUMin:
  case spv::OpAtomicSMax:
  case spv::OpAtomicUMax:
  case spv::OpAtomicAnd:
  case spv::OpAtomicOr:
  case spv::OpAtomicXor:
  case spv::OpAtomicFlagTestAndSet:
    defs[args[2]].mark_used();
    if (defs[args[2]]._type != nullptr &&
        defs[args[2]]._type->contains_scalar_type(ShaderType::ST_double)) {
      _used_caps |= C_double;
    }
    break;

  case spv::OpCopyMemory:
  case spv::OpCopyMemorySized:
    defs[args[1]].mark_used();
    if (defs[args[1]]._type != nullptr &&
        defs[args[1]]._type->contains_scalar_type(ShaderType::ST_double)) {
      _used_caps |= C_double;
    }
    break;

  case spv::OpDecorate:
    switch ((spv::Decoration)args[1]) {
    case spv::DecorationBuiltIn:
      defs[args[0]]._builtin = (spv::BuiltIn)args[2];
      break;

    case spv::DecorationLocation:
      defs[args[0]]._location = args[2];
      break;

    default:
      break;
    }
    /*if (args[1] == spv::DecorationLocation || args[1] == spv::DecorationBinding) {
      vars[args[0]]._location = args[2];
    } else if (args[1] == spv::DecorationDescriptorSet) {
      vars[args[0]]._set = args[2];
    }*/
    break;

  case spv::OpImageRead:
  case spv::OpImageWrite:
    _used_caps |= C_image_load_store;
    break;

  case spv::OpImageFetch:
  case spv::OpImageQuerySizeLod:
  case spv::OpImageQuerySize:
    _used_caps |= C_texture_fetch;
    break;

  case spv::OpImageQueryLod:
    _used_caps |= C_texture_query_lod;
    break;

  case spv::OpImageQueryLevels:
    _used_caps |= C_texture_query_levels;
    break;

  case spv::OpImageQuerySamples:
    _used_caps |= C_texture_query_samples;
    break;

  case spv::OpBitcast:
    _used_caps |= C_bit_encoding;
    break;


  case spv::OpIAddCarry:
  case spv::OpISubBorrow:
  case spv::OpUMulExtended:
  case spv::OpSMulExtended:
    _used_caps |= C_extended_arithmetic;
    break;

  case spv::OpDPdxFine:
  case spv::OpDPdyFine:
  case spv::OpFwidthFine:
  case spv::OpDPdxCoarse:
  case spv::OpDPdyCoarse:
  case spv::OpFwidthCoarse:
    _used_caps |= C_derivative_control;
    break;

  default:
    break;
  }

  return true;
}

/**
 * Assigns location decorations to all input, output and uniform variables that
 * do not have a location decoration yet.
 */
void ShaderModuleSpirV::
assign_locations(Definitions &defs) {
  // Determine which locations have already been assigned.
  bool has_unassigned_locations = false;
  BitArray input_locations;
  BitArray output_locations;
  BitArray uniform_locations;

  for (const Definition &def : defs) {
    if (def._dtype == DT_variable) {
      if (def._location < 0) {
        if (def._builtin == spv::BuiltInMax &&
            (def._storage_class == spv::StorageClassInput ||
             def._storage_class == spv::StorageClassOutput ||
             def._storage_class == spv::StorageClassUniformConstant)) {
          // A non-built-in variable definition without a location.
          has_unassigned_locations = true;
        }
      }
      else if (def._storage_class == spv::StorageClassInput) {
        input_locations.set_bit(def._location);
      }
      else if (def._storage_class == spv::StorageClassOutput) {
        output_locations.set_bit(def._location);
      }
      else if (def._storage_class == spv::StorageClassUniformConstant) {
        uniform_locations.set_range(def._location, def._type ? def._type->get_num_parameter_locations() : 1);
      }
    }
  }

  if (!has_unassigned_locations) {
    return;
  }

  // Insert decorations for every unassigned variable at the beginning of the
  // annotations block.
  InstructionIterator it = _instructions.begin_annotations();
  for (uint32_t id = 0; id < defs.size(); ++id) {
    Definition &def = defs[id];
    if (def._dtype == DT_variable &&
        def._location < 0 &&
        def._builtin == spv::BuiltInMax) {
      int location;
      if (def._storage_class == spv::StorageClassInput) {
        if (get_stage() == Stage::vertex && !input_locations.get_bit(0)) {
          if (def._name == "vertex" || def._name == "p3d_Vertex" ||
              def._name == "vtx_position") {
            // Prefer assigning the vertex column to location 0.
            location = 0;
          } else if (!input_locations.get_bit(1)) {
            location = 1;
          } else {
            location = input_locations.get_next_higher_different_bit(1);
          }
        } else {
          location = input_locations.get_lowest_off_bit();
        }
        input_locations.set_bit(location);

        if (shader_cat.is_debug()) {
          shader_cat.debug()
            << "Assigning " << def._name << " to input location " << location << "\n";
        }
      }
      else if (def._storage_class == spv::StorageClassOutput) {
        location = output_locations.get_lowest_off_bit();
        output_locations.set_bit(location);

        if (shader_cat.is_debug()) {
          shader_cat.debug()
            << "Assigning " << def._name << " to output location " << location << "\n";
        }
      }
      else if (def._storage_class == spv::StorageClassUniformConstant) {
        int num_locations = def._type->get_num_parameter_locations();
        location = uniform_locations.get_lowest_off_bit();
        while (num_locations > 1 && uniform_locations.has_any_of(location, num_locations)) {
          // Not enough bits free, try the next open range.
          int next_bit = uniform_locations.get_next_higher_different_bit(location);
          assert(next_bit > location);
          location = uniform_locations.get_next_higher_different_bit(next_bit);
          assert(location >= 0);
        }
        uniform_locations.set_range(location, num_locations);

        if (shader_cat.is_debug()) {
          if (num_locations == 1) {
            shader_cat.debug()
              << "Assigning " << def._name << " to uniform location " << location << "\n";
          } else {
            shader_cat.debug()
              << "Assigning " << def._name << " to uniform locations " << location
              << ".." << (location + num_locations - 1) << "\n";
          }
        }
      }
      else {
        continue;
      }

      def._location = location;
      it = _instructions.insert(it,
        spv::OpDecorate, {id, spv::DecorationLocation, (uint32_t)location});
      ++it;
    }
  }
}

/**
 * Changes the locations for all inputs of the given storage class based on the
 * indicated map.  Note that this only works for inputs that already have an
 * assigned location; assign_locations() may have to be called first to ensure
 * that.
 */
void ShaderModuleSpirV::
remap_locations(spv::StorageClass storage_class, const pmap<int, int> &locations) {
  pmap<uint32_t, uint32_t *> decorations;

  for (Instruction op : _instructions) {
    if (op.opcode == spv::OpDecorate) {
      // Store the location of this decoration in the bytecode.
      if ((spv::Decoration)op.args[1] == spv::DecorationLocation && op.nargs >= 3) {
        decorations[op.args[0]] = &op.args[2];
      }
    }
    else if (op.opcode == spv::OpVariable && (spv::StorageClass)op.args[2] == storage_class) {
      // Found a variable, did we store the location for its decoration?
      pmap<uint32_t, uint32_t *>::const_iterator it = decorations.find(op.args[1]);
      if (it != decorations.end()) {
        // Yes, do we have a remapping for it?
        pmap<int, int>::const_iterator it2 = locations.find((int)*(it->second));
        if (it2 != locations.end()) {
          // Yes, write the new location into the bytecode.
          *(it->second) = (uint32_t)it2->second;
        }
      }
    }
  }
}

/**
 * Converts the members of the struct type with the given ID to regular
 * variables.
 */
void ShaderModuleSpirV::
flatten_struct(Definitions &defs, uint32_t type_id) {
  const ShaderType::Struct *struct_type;
  DCAST_INTO_V(struct_type, defs[type_id]._type);

  pset<uint32_t> deleted_ids;
  pmap<uint32_t, uint32_t> deleted_access_chains;

  pvector<uint32_t> member_ids(struct_type->get_num_members());

  InstructionIterator it = _instructions.begin();
  while (it != _instructions.end()) {
    Instruction op = *it;

    switch (op.opcode) {
    case spv::OpName:
    case spv::OpMemberName:
    case spv::OpDecorate:
    case spv::OpMemberDecorate:
      // Delete decorations on the struct type.
      if (op.nargs >= 1 && op.args[0] == type_id) {
        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpTypeStruct:
      // Delete the struct definition itself.
      if (op.nargs >= 1 && op.args[0] == type_id) {
        defs[type_id].clear();
        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpTypePointer:
      if (op.nargs >= 3 && op.args[2] == type_id) {
        // Remember this pointer.
        deleted_ids.insert(op.args[0]);
        defs[op.args[0]].clear();
        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpVariable:
      if (op.nargs >= 3 && deleted_ids.count(op.args[0])) {
        // Delete this variable entirely, and replace it instead with individual
        // variable definitions for all its members.
        uint32_t struct_var_id = op.args[1];
        int struct_location = defs[struct_var_id]._location;
        deleted_ids.insert(struct_var_id);
        it = _instructions.erase(it);

        std::string struct_var_name = std::move(defs[struct_var_id]._name);
        defs[struct_var_id].clear();

        for (size_t mi = 0; mi < struct_type->get_num_members(); ++mi) {
          const ShaderType::Struct::Member &member = struct_type->get_member(mi);

          // Find type identifier.
          uint32_t type_id = 0;
          for (uint32_t id = 0; id < defs.size(); ++id) {
            if (defs[id]._type == member.type && defs[id]._dtype == DT_type) {
              type_id = id;
            }
          }

          // Create a type pointer for it.
          nassertv(type_id > 0);

          // Create an OpTypePointer instruction.
          uint32_t type_pointer_id = _instructions.allocate_id();

          it = _instructions.insert(it, spv::OpTypePointer, {
            type_pointer_id,
            spv::StorageClassUniformConstant,
            type_id,
          });
          ++it;

          defs.push_back(Definition());
          defs[type_pointer_id].set_type_pointer(spv::StorageClassUniformConstant, member.type);

          // Insert a new variable for this struct member.
          uint32_t variable_id = _instructions.allocate_id();
          it = _instructions.insert(it, spv::OpVariable, {
            type_pointer_id,
            variable_id,
            spv::StorageClassUniformConstant,
          });
          ++it;

          defs.push_back(Definition());
          if (struct_var_name.empty()) {
            defs[variable_id]._name = member.name;
          } else {
            defs[variable_id]._name = struct_var_name + "." + member.name;
          }
          if (struct_location >= 0) {
            // Assign decorations to the individual members.
            int location = struct_location + mi;
            defs[variable_id]._location = location;
          }
          defs[variable_id].set_variable(member.type, spv::StorageClassUniformConstant);

          member_ids[mi] = variable_id;
        }
        continue;
      }
      break;

    case spv::OpAccessChain:
    case spv::OpInBoundsAccessChain:
    case spv::OpPtrAccessChain:
      if (deleted_ids.count(op.args[2])) {
        uint32_t index = defs[op.args[3]]._constant;
        if (op.nargs > 4) {
          // Just unwrap the first index.
          op.args[2] = member_ids[index];
          it = _instructions.erase_arg(it, 3);
        } else {
          // Delete the access chain entirely.
          deleted_access_chains[op.args[1]] = member_ids[index];
          it = _instructions.erase(it);
          continue;
        }
      }
      break;

    case spv::OpLoad:
      // If this triggers, the struct is being loaded into another variable,
      // which means we can't unwrap this (for now).
      nassertv(!deleted_ids.count(op.args[2]));

      if (deleted_access_chains.count(op.args[2])) {
        op.args[2] = deleted_access_chains[op.args[2]];
      }
      break;

    case spv::OpCopyMemory:
    case spv::OpCopyMemorySized:
      // Shouldn't be copying the struct directly.
      nassertv(!deleted_ids.count(op.args[1]));

      if (deleted_access_chains.count(op.args[1])) {
        op.args[1] = deleted_access_chains[op.args[1]];
      }
      break;

    default:
      break;
    }

    ++it;
  }

  // Insert decorations for the individual members.
  it = _instructions.begin_annotations();
  for (uint32_t var_id : member_ids) {
    int location = defs[var_id]._location;
    if (location >= 0) {
      it = _instructions.insert(it,
        spv::OpDecorate, {var_id, spv::DecorationLocation, (uint32_t)location});
    }
  }

  // Go over it again now that we know the deleted IDs, to remove any
  // decorations on them.
  if (deleted_ids.empty()) {
    return;
  }

  it = _instructions.begin();
  while (it != _instructions.end()) {
    Instruction op = *it;

    if ((op.opcode == spv::OpName || op.opcode == spv::OpDecorate || op.opcode == spv::OpMemberName || op.opcode == spv::OpMemberDecorate) &&
        op.nargs >= 2 && deleted_ids.count(op.args[0])) {
      _instructions.erase(it);
      continue;
    }

    ++it;
  }
}

/**
 * Strips debugging information from the SPIR-V binary.
 */
void ShaderModuleSpirV::
strip() {
  _instructions = _instructions.strip();
}

/**
 * Returns a stripped copy of the instruction stream.
 */
ShaderModuleSpirV::InstructionStream ShaderModuleSpirV::InstructionStream::
strip() const {
  const uint32_t *words = (const uint32_t *)_words.data();
  const size_t length = _words.size();
  const uint32_t *end = words + length;

  // Create a new instruction stream, in which we copy the header for now.
  InstructionStream copy(words, 5);

  // Copy all non-debug instructions to the new vector.
  words += 5;
  while (words < end) {
    uint16_t wcount = words[0] >> spv::WordCountShift;
    spv::Op opcode = (spv::Op)(words[0] & spv::OpCodeMask);
    nassertr(wcount > 0, copy);

    if (opcode != spv::OpNop &&
        opcode != spv::OpSourceContinued &&
        opcode != spv::OpSource &&
        opcode != spv::OpSourceExtension &&
        opcode != spv::OpName &&
        opcode != spv::OpMemberName &&
        opcode != spv::OpString &&
        opcode != spv::OpLine &&
        opcode != spv::OpNoLine &&
        opcode != spv::OpModuleProcessed) {

      copy._words.insert(copy._words.end(), words, words + wcount);
    }
    words += wcount;
  }

  return copy;
}

/**
 * Called when an OpName is encountered in the SPIR-V instruction stream.
 */
void ShaderModuleSpirV::Definition::
set_name(const char *name) {
  _name.assign(name);
}

/**
 * Called when an OpMemberName is encountered in the SPIR-V instruction stream.
 */
void ShaderModuleSpirV::Definition::
set_member_name(uint32_t i, const char *name) {
  if (i >= _member_names.size()) {
    _member_names.resize(i + 1);
  }
  _member_names[i].assign(name);
}

/**
 * Called when an OpType is encountered in the SPIR-V instruction stream.
 */
void ShaderModuleSpirV::Definition::
set_type(const ShaderType *type) {
  _dtype = DT_type;
  _type = type;

  if (shader_cat.is_spam()) {
    if (type != nullptr) {
      shader_cat.spam()
        << "Defined type " << *type << "\n";
    } else {
      shader_cat.spam()
        << "Defined type void\n";
    }
  }
}

/**
 * Called when an OpTypePointer is encountered in the SPIR-V instruction stream.
 */
void ShaderModuleSpirV::Definition::
set_type_pointer(spv::StorageClass storage_class, const ShaderType *type) {
  _dtype = DT_type_pointer;
  _type = type;
}

/**
 * Called when an OpVariable is encountered in the SPIR-V instruction stream.
 */
void ShaderModuleSpirV::Definition::
set_variable(const ShaderType *type, spv::StorageClass storage_class) {
  _dtype = DT_variable;
  _type = type;
  _storage_class = storage_class;

  if (shader_cat.is_debug() && storage_class == spv::StorageClassUniformConstant) {
    shader_cat.debug()
      << "Defined uniform " << _name;

    if (_location >= 0) {
      shader_cat.debug(false) << " (location " << _location << ")";
    }

    shader_cat.debug(false) << " with ";

    if (type != nullptr) {
      shader_cat.debug(false) << "type " << *type << "\n";
    } else {
      shader_cat.debug(false) << "unknown type\n";
    }
  }

  switch (storage_class) {
  case spv::StorageClassUniformConstant:
    //_uniform_constants.push_back(&def);
    break;
  case spv::StorageClassInput:
    //_inputs.push_back(Varying({}));
    break;
  case spv::StorageClassUniform:
    break;
  case spv::StorageClassOutput:
    //_outputs.push_back(&def);
    break;
  case spv::StorageClassWorkgroup:
  case spv::StorageClassCrossWorkgroup:
  case spv::StorageClassPrivate:
  case spv::StorageClassFunction:
  case spv::StorageClassGeneric:
  case spv::StorageClassPushConstant:
  case spv::StorageClassAtomicCounter:
  case spv::StorageClassImage:
    break;

  default:
    break;
  }
}

/**
 * Called when an OpConstant is encountered in the SPIR-V instruction stream.
 */
void ShaderModuleSpirV::Definition::
set_constant(const ShaderType *type, const uint32_t *words, uint32_t nwords) {
  _dtype = DT_constant;
  _type = type;
  if (nwords > 0) {
    _constant = words[0];
  } else {
    _constant = 0;
  }
}

/**
 * Called when OpExtInstImport is encountered in the SPIR-V instruction stream.
 */
void ShaderModuleSpirV::Definition::
set_ext_inst(const char *name) {
  _dtype = DT_ext_inst;
  _name.assign(name);
}

/**
 * Marks the variable as having been loaded.
 */
void ShaderModuleSpirV::Definition::
mark_used() {
  _used = true;
}

/**
 * Clears this definition, in case it has just been removed.
 */
void ShaderModuleSpirV::Definition::
clear() {
  _dtype = DT_none;
  _name.clear();
  _type = nullptr;
  _location = -1;
  _builtin = spv::BuiltInMax;
  _constant = 0;
  _member_names.clear();
}
