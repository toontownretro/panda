/**
 * PANDA 3D SOFTWARE
 * Copyright (c) Carnegie Mellon University.  All rights reserved.
 *
 * All use of this software is subject to the terms of the revised BSD
 * license.  You should have received a copy of this license along
 * with this source code in a file named "LICENSE."
 *
 * @file shaderModuleSpirV.cxx
 * @author rdb
 * @date 2019-07-15
 */

#include "shaderModuleSpirV.h"
#include "string_utils.h"
#include "shaderType.h"

TypeHandle ShaderModuleSpirV::_type_handle;

/**
 * Takes a stream of SPIR-V instructions, and processes it as follows:
 * - All the definitions are parsed out (requires debug info present)
 * - Makes sure that all the inputs have location indices assigned.
 * - Builds up the lists of inputs, outputs and parameters.
 * - Strips debugging information from the module.
 */
ShaderModuleSpirV::
ShaderModuleSpirV(Stage stage, std::vector<uint32_t> words) :
  ShaderModule(stage),
  _instructions(std::move(words))
{
  if (!_instructions.validate_header()) {
    return;
  }

  InstructionWriter writer(_instructions);

  // Check for caps and sanity.
  for (InstructionIterator it = _instructions.begin(); it != _instructions.begin_annotations(); ++it) {
    Instruction op = *it;
    switch (op.opcode) {
    case spv::OpExtInst:
      {
        const Definition &def = writer.get_definition(op.args[2]);
        nassertv(def._dtype == DT_ext_inst);
        if (def._name == "GLSL.std.450" && op.args[3] == 2) {
          // We mark the use of the GLSL roundEven() function, which is not
          // supported by HLSL and requires GLSL 1.30.
          _used_caps |= C_round_even;
        }
      }
      break;

    case spv::OpMemoryModel:
      if (op.args[0] != spv::AddressingModelLogical) {
        shader_cat.error()
          << "Invalid SPIR-V shader: addressing model Logical must be used.\n";
        return;
      }
      if (op.args[1] != spv::MemoryModelGLSL450) {
        shader_cat.error()
          << "Invalid SPIR-V shader: memory model GLSL450 must be used.\n";
        return;
      }
      break;

    case spv::OpCapability:
      switch ((spv::Capability)op.args[0]) {
      case spv::CapabilityFloat64:
        _used_caps |= C_double;
        break;

      case spv::CapabilityImageCubeArray:
        _used_caps |= C_cube_map_array;
        break;

      default:
        break;
      }
      break;

    default:
      break;
    }
  }

  // Check if there is a $Global uniform block.  This is generated by the HLSL
  // front-end of glslang.  If so, unwrap it back down to individual uniforms.
  uint32_t type_id = writer.find_definition("$Global");
  if (type_id) {
    writer.flatten_struct(type_id);
  }

  // Add in location decorations for any inputs that are missing it.
  writer.assign_locations(stage);

  // Identify the inputs, outputs and uniform parameters.
  for (uint32_t id = 0; id < _instructions.get_id_bound(); ++id) {
    const Definition &def = writer.get_definition(id);

    if (def._used && def._type != nullptr &&
        def._type->contains_scalar_type(ShaderType::ST_double)) {
      _used_caps |= C_double;
    }

    if (def._dtype == DT_variable && def._builtin == spv::BuiltInMax) {
      Variable var;
      var.type = def._type;
      var.name = InternalName::make(def._name);
      var._location = def._location;
      //var._id = id;

      if (def._storage_class == spv::StorageClassInput) {
        _inputs.push_back(std::move(var));
      }
      else if (def._storage_class == spv::StorageClassOutput) {
        _outputs.push_back(std::move(var));
      }
      else if (def._storage_class == spv::StorageClassUniformConstant) {
        _parameters.push_back(std::move(var));
      }

      if (def._type->contains_scalar_type(ShaderType::ST_int) ||
          def._type->contains_scalar_type(ShaderType::ST_uint)) {
        _used_caps |= C_integer;
      }
    }
    else if (def._dtype == DT_variable && def._used &&
             def._storage_class == spv::StorageClassInput) {
      // Built-in input variable.
      switch (def._builtin) {
      case spv::BuiltInVertexId:
        _used_caps |= C_vertex_id;
        break;

      case spv::BuiltInInstanceId:
        _used_caps |= C_instance_id;
        break;

      case spv::BuiltInPrimitiveId:
        _used_caps |= C_primitive_id;
        break;

      case spv::BuiltInSampleId:
      case spv::BuiltInSampleMask:
      case spv::BuiltInSamplePosition:
        _used_caps |= C_sample_variables;
        break;

      default:
        break;
      }
    }
  }

  // We no longer need the debugging information, so it can be safely stripped
  // from the module.
  strip();

  // Check for more caps.
  for (InstructionIterator it = _instructions.begin_functions(); it != _instructions.end(); ++it) {
    Instruction op = *it;
    switch (op.opcode) {
    case spv::OpImageRead:
    case spv::OpImageWrite:
      _used_caps |= C_image_load_store;
      break;

    case spv::OpImageFetch:
    case spv::OpImageQuerySizeLod:
    case spv::OpImageQuerySize:
      _used_caps |= C_texture_fetch;
      break;

    case spv::OpImageQueryLod:
      _used_caps |= C_texture_query_lod;
      break;

    case spv::OpImageQueryLevels:
      _used_caps |= C_texture_query_levels;
      break;

    case spv::OpImageQuerySamples:
      _used_caps |= C_texture_query_samples;
      break;

    case spv::OpBitcast:
      _used_caps |= C_bit_encoding;
      break;

    case spv::OpIAddCarry:
    case spv::OpISubBorrow:
    case spv::OpUMulExtended:
    case spv::OpSMulExtended:
      _used_caps |= C_extended_arithmetic;
      break;

    case spv::OpDPdxFine:
    case spv::OpDPdyFine:
    case spv::OpFwidthFine:
    case spv::OpDPdxCoarse:
    case spv::OpDPdyCoarse:
    case spv::OpFwidthCoarse:
      _used_caps |= C_derivative_control;
      break;

    default:
      break;
    }
  }
}

ShaderModuleSpirV::
~ShaderModuleSpirV() {
}

/**
 * Required to implement CopyOnWriteObject.
 */
PT(CopyOnWriteObject) ShaderModuleSpirV::
make_cow_copy() {
  return new ShaderModuleSpirV(*this);
}

std::string ShaderModuleSpirV::
get_ir() const {
  return std::string();
}

/**
 * Links the stage with the given previous stage, by matching up its inputs with
 * the outputs of the previous stage and assigning locations.
 */
bool ShaderModuleSpirV::
link_inputs(const ShaderModule *previous) {
  if (!previous->is_of_type(ShaderModuleSpirV::get_class_type())) {
    return false;
  }
  if (previous->get_stage() >= get_stage()) {
    return false;
  }

  pmap<int, int> location_remap;

  ShaderModuleSpirV *spv_prev = (ShaderModuleSpirV *)previous;

  for (const Variable &input : _inputs) {
    int i = spv_prev->find_output(input.name);
    if (i < 0) {
      shader_cat.error()
        << "Input " << *input.name << " in stage " << get_stage()
        << " does not match any output in stage " << previous->get_stage() << "!\n";
      return false;
    }

    const Variable &output = spv_prev->get_output((size_t)i);
    if (!output.has_location()) {
      shader_cat.error()
        << "Output " << *input.name << " in stage " << previous->get_stage()
        << " has no output location!\n";
      return false;
    }

    if (!input.has_location() || output.get_location() != input.get_location()) {
      location_remap[input.get_location()] = output.get_location();
    }
  }

  if (!location_remap.empty()) {
    remap_locations(spv::StorageClassInput, location_remap);
  }
  return true;
}

/**
 * Remaps parameters with a given location to a given other location.  Locations
 * not included in the map remain untouched.
 */
void ShaderModuleSpirV::
remap_parameter_locations(pmap<int, int> &locations) {
  remap_locations(spv::StorageClassUniformConstant, locations);

  // If we extracted out the parameters, replace the locations there as well.
  for (Variable &parameter : _parameters) {
    if (parameter.has_location()) {
      pmap<int, int>::const_iterator it = locations.find(parameter.get_location());
      if (it != locations.end()) {
        parameter._location = it->second;
      }
    }
  }
}

/**
 * Validates the header of the instruction stream.
 */
bool ShaderModuleSpirV::InstructionStream::
validate_header() const {
  if (_words.size() < 5) {
    shader_cat.error()
      << "Invalid SPIR-V file: too short.\n";
    return false;
  }

  // Validate the header.
  const uint32_t *words = (const uint32_t *)&_words[0];
  if (*words++ != spv::MagicNumber) {
    shader_cat.error()
      << "Invalid SPIR-V file: wrong magic number.\n";
    return false;
  }

  return true;
}

/**
 * Changes the locations for all inputs of the given storage class based on the
 * indicated map.  Note that this only works for inputs that already have an
 * assigned location; assign_locations() may have to be called first to ensure
 * that.
 */
void ShaderModuleSpirV::
remap_locations(spv::StorageClass storage_class, const pmap<int, int> &locations) {
  pmap<uint32_t, uint32_t *> decorations;

  for (Instruction op : _instructions) {
    if (op.opcode == spv::OpDecorate) {
      // Store the location of this decoration in the bytecode.
      if ((spv::Decoration)op.args[1] == spv::DecorationLocation && op.nargs >= 3) {
        decorations[op.args[0]] = &op.args[2];
      }
    }
    else if (op.opcode == spv::OpVariable && (spv::StorageClass)op.args[2] == storage_class) {
      // Found a variable, did we store the location for its decoration?
      pmap<uint32_t, uint32_t *>::const_iterator it = decorations.find(op.args[1]);
      if (it != decorations.end()) {
        // Yes, do we have a remapping for it?
        pmap<int, int>::const_iterator it2 = locations.find((int)*(it->second));
        if (it2 != locations.end()) {
          // Yes, write the new location into the bytecode.
          *(it->second) = (uint32_t)it2->second;
        }
      }
    }
  }
}

/**
 * Strips debugging information from the SPIR-V binary.
 */
void ShaderModuleSpirV::
strip() {
  // Create a new instruction stream, in which we copy the header for now.
  InstructionStream copy(get_data(), 5);

  // Copy all non-debug instructions to the new vector.
  for (Instruction op : _instructions) {
    if (op.opcode != spv::OpNop && !op.is_debug()) {
      copy.insert(copy.end(), op);
    }
  }

  _instructions = copy;
}

/**
 * Returns true if this type contains anything decorated with BuiltIn.
 */
bool ShaderModuleSpirV::Definition::
has_builtin() const {
  if (_builtin != spv::BuiltInMax) {
    return true;
  }
  for (const MemberDefinition &def : _members) {
    if (def._builtin != spv::BuiltInMax) {
      return true;
    }
  }
  return false;
}

/**
 * Returns a MemberDefinition for the given member.
 */
const ShaderModuleSpirV::MemberDefinition &ShaderModuleSpirV::Definition::
get_member(uint32_t i) const {
  static MemberDefinition default_def;
  if (i >= _members.size()) {
    return default_def;
  }
  return _members[i];
}

/**
 * Returns a modifiable MemberDefinition for the given member.
 */
ShaderModuleSpirV::MemberDefinition &ShaderModuleSpirV::Definition::
modify_member(uint32_t i) {
  if (i >= _members.size()) {
    _members.resize(i + 1);
  }
  return _members[i];
}

/**
 * Clears this definition, in case it has just been removed.
 */
void ShaderModuleSpirV::Definition::
clear() {
  _dtype = DT_none;
  _name.clear();
  _type = nullptr;
  _location = -1;
  _builtin = spv::BuiltInMax;
  _constant = 0;
  _members.clear();
}

/**
 * Constructs an instruction writer to operate on the given instruction stream.
 */
ShaderModuleSpirV::InstructionWriter::
InstructionWriter(InstructionStream &stream) :
  _instructions(stream),
  _defs(_instructions.get_id_bound()) {

  for (Instruction op : _instructions) {
    parse_instruction(op);
  }
}

/**
 * Finds the definition with the given name.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
find_definition(const std::string &name) const {
  for (uint32_t id = 0; id < _defs.size(); ++id) {
    if (_defs[id]._name == name) {
      return id;
    }
  }

  return 0;
}

/**
 * Returns the definition by its identifier.
 */
const ShaderModuleSpirV::Definition &ShaderModuleSpirV::InstructionWriter::
get_definition(uint32_t id) const {
  if (id >= _defs.size()) {
    static Definition default_def;
    return default_def;
  }
  return _defs[id];
}

/**
 * Returns a mutable definition by its identifier.
 */
ShaderModuleSpirV::Definition &ShaderModuleSpirV::InstructionWriter::
modify_definition(uint32_t id) {
  if (id >= _defs.size()) {
    _defs.resize(id + 1);
  }
  return _defs[id];
}

/**
 * Assigns location decorations to all input, output and uniform variables that
 * do not have a location decoration yet.
 */
void ShaderModuleSpirV::InstructionWriter::
assign_locations(Stage stage) {
  // Determine which locations have already been assigned.
  bool has_unassigned_locations = false;
  BitArray input_locations;
  BitArray output_locations;
  BitArray uniform_locations;

  for (const Definition &def : _defs) {
    if (def._dtype == DT_variable) {
      if (def._location < 0) {
        if (def._builtin == spv::BuiltInMax &&
            (def._storage_class == spv::StorageClassInput ||
             def._storage_class == spv::StorageClassOutput ||
             def._storage_class == spv::StorageClassUniformConstant)) {
          // A non-built-in variable definition without a location.
          has_unassigned_locations = true;
        }
      }
      else if (def._storage_class == spv::StorageClassInput) {
        input_locations.set_range(def._location, def._type ? def._type->get_num_interface_locations() : 1);
      }
      else if (def._storage_class == spv::StorageClassOutput) {
        output_locations.set_range(def._location, def._type ? def._type->get_num_interface_locations() : 1);
      }
      else if (def._storage_class == spv::StorageClassUniformConstant) {
        uniform_locations.set_range(def._location, def._type ? def._type->get_num_parameter_locations() : 1);
      }
    }
  }

  if (!has_unassigned_locations) {
    return;
  }

  // Insert decorations for every unassigned variable at the beginning of the
  // annotations block.
  InstructionIterator it = _instructions.begin_annotations();
  for (uint32_t id = 0; id < _defs.size(); ++id) {
    Definition &def = _defs[id];
    if (def._dtype == DT_variable &&
        def._location < 0 &&
        def._builtin == spv::BuiltInMax) {
      int location;
      if (def._storage_class == spv::StorageClassInput) {
        int num_locations = def._type->get_num_interface_locations();
        if (num_locations == 0) {
          continue;
        }

        if (stage == Stage::vertex && !input_locations.get_bit(0)) {
          if (def._name == "vertex" || def._name == "p3d_Vertex" ||
              def._name == "vtx_position") {
            // Prefer assigning the vertex column to location 0.
            location = 0;
          } else if (!input_locations.get_bit(1)) {
            location = 1;
          } else {
            location = input_locations.get_next_higher_different_bit(1);
          }
        } else {
          location = input_locations.get_lowest_off_bit();
        }
        input_locations.set_bit(location);

        if (shader_cat.is_debug()) {
          shader_cat.debug()
            << "Assigning " << def._name << " to input location " << location << "\n";
        }
      }
      else if (def._storage_class == spv::StorageClassOutput) {
        int num_locations = def._type->get_num_interface_locations();
        if (num_locations == 0) {
          continue;
        }

        location = output_locations.get_lowest_off_bit();
        output_locations.set_bit(location);

        if (shader_cat.is_debug()) {
          shader_cat.debug()
            << "Assigning " << def._name << " to output location " << location << "\n";
        }
      }
      else if (def._storage_class == spv::StorageClassUniformConstant) {
        int num_locations = def._type->get_num_parameter_locations();
        if (num_locations == 0) {
          continue;
        }

        location = uniform_locations.get_lowest_off_bit();
        while (num_locations > 1 && uniform_locations.has_any_of(location, num_locations)) {
          // Not enough bits free, try the next open range.
          int next_bit = uniform_locations.get_next_higher_different_bit(location);
          assert(next_bit > location);
          location = uniform_locations.get_next_higher_different_bit(next_bit);
          assert(location >= 0);
        }
        uniform_locations.set_range(location, num_locations);

        if (shader_cat.is_debug()) {
          if (num_locations == 1) {
            shader_cat.debug()
              << "Assigning " << def._name << " to uniform location " << location << "\n";
          } else {
            shader_cat.debug()
              << "Assigning " << def._name << " to uniform locations " << location
              << ".." << (location + num_locations - 1) << "\n";
          }
        }
      }
      else {
        continue;
      }

      def._location = location;
      it = _instructions.insert(it,
        spv::OpDecorate, {id, spv::DecorationLocation, (uint32_t)location});
      ++it;
    }
  }
}

/**
 * Assign descriptor bindings for a descriptor set based on the given locations.
 * Assumes there are already binding and set decorations.
 * To create gaps in the descriptor set, entries in locations may be -1.
 */
void ShaderModuleSpirV::InstructionWriter::
bind_descriptor_set(uint32_t set, const vector_int &locations) {
  for (InstructionIterator it = _instructions.begin_annotations();
       it != _instructions.end() && (*it).is_annotation();
       ++it) {
    Instruction op = *it;

    if (op.opcode == spv::OpDecorate && op.nargs >= 3) {
      Definition &def = _defs[op.args[0]];

      auto lit = std::find(locations.begin(), locations.end(), def._location);
      if (lit != locations.end() && def._location >= 0) {
        if (op.args[1] == spv::DecorationBinding) {
          op.args[2] = std::distance(locations.begin(), lit);
        }
        else if (op.args[1] == spv::DecorationDescriptorSet) {
          op.args[2] = set;
        }
      }
    }
  }
}

/**
 * Converts the members of the struct type with the given ID to regular
 * variables.  Useful for unwrapping uniform blocks.
 */
void ShaderModuleSpirV::InstructionWriter::
flatten_struct(uint32_t type_id) {
  const ShaderType::Struct *struct_type;
  DCAST_INTO_V(struct_type, _defs[type_id]._type);

  pset<uint32_t> deleted_ids;
  pmap<uint32_t, uint32_t> deleted_access_chains;

  pvector<uint32_t> member_ids(struct_type->get_num_members());

  InstructionIterator it = _instructions.begin();
  while (it != _instructions.end()) {
    Instruction op = *it;

    switch (op.opcode) {
    case spv::OpName:
    case spv::OpMemberName:
    case spv::OpDecorate:
    case spv::OpMemberDecorate:
      // Delete decorations on the struct type.
      if (op.nargs >= 1 && op.args[0] == type_id) {
        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpTypeStruct:
      // Delete the struct definition itself.
      if (op.nargs >= 1 && op.args[0] == type_id) {
        _defs[type_id].clear();
        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpTypePointer:
      if (op.nargs >= 3 && op.args[2] == type_id) {
        // Remember this pointer.
        deleted_ids.insert(op.args[0]);
        _defs[op.args[0]].clear();
        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpVariable:
      if (op.nargs >= 3 && deleted_ids.count(op.args[0])) {
        // Delete this variable entirely, and replace it instead with individual
        // variable definitions for all its members.
        uint32_t struct_var_id = op.args[1];
        int struct_location = _defs[struct_var_id]._location;
        deleted_ids.insert(struct_var_id);
        it = _instructions.erase(it);

        std::string struct_var_name = std::move(_defs[struct_var_id]._name);
        _defs[struct_var_id].clear();

        for (size_t mi = 0; mi < struct_type->get_num_members(); ++mi) {
          const ShaderType::Struct::Member &member = struct_type->get_member(mi);

          // Insert a new variable for this struct member.
          uint32_t variable_id = r_define_variable(it, member.type, spv::StorageClassUniformConstant);

          Definition &variable_def = modify_definition(variable_id);
          if (struct_var_name.empty()) {
            variable_def._name = member.name;
          } else {
            variable_def._name = struct_var_name + "." + member.name;
          }
          if (struct_location >= 0) {
            // Assign decorations to the individual members.
            int location = struct_location + mi;
            variable_def._location = location;
          }

          member_ids[mi] = variable_id;
        }
        continue;
      }
      break;

    case spv::OpAccessChain:
    case spv::OpInBoundsAccessChain:
    case spv::OpPtrAccessChain:
      if (deleted_ids.count(op.args[2])) {
        uint32_t index = _defs[op.args[3]]._constant;
        if (op.nargs > 4) {
          // Just unwrap the first index.
          op.args[2] = member_ids[index];
          it = _instructions.erase_arg(it, 3);
        } else {
          // Delete the access chain entirely.
          deleted_access_chains[op.args[1]] = member_ids[index];
          it = _instructions.erase(it);
          continue;
        }
      }
      break;

    case spv::OpLoad:
      // If this triggers, the struct is being loaded into another variable,
      // which means we can't unwrap this (for now).
      nassertv(!deleted_ids.count(op.args[2]));

      if (deleted_access_chains.count(op.args[2])) {
        op.args[2] = deleted_access_chains[op.args[2]];
      }
      break;

    case spv::OpCopyMemory:
    case spv::OpCopyMemorySized:
      // Shouldn't be copying the struct directly.
      nassertv(!deleted_ids.count(op.args[1]));

      if (deleted_access_chains.count(op.args[1])) {
        op.args[1] = deleted_access_chains[op.args[1]];
      }
      break;

    default:
      break;
    }

    ++it;
  }

  // Insert decorations for the individual members.
  it = _instructions.begin_annotations();
  for (uint32_t var_id : member_ids) {
    int location = _defs[var_id]._location;
    if (location >= 0) {
      it = _instructions.insert(it,
        spv::OpDecorate, {var_id, spv::DecorationLocation, (uint32_t)location});
    }
  }

  // Go over it again now that we know the deleted IDs, to remove any
  // decorations on them.
  if (deleted_ids.empty()) {
    return;
  }

  it = _instructions.begin();
  while (it != _instructions.end()) {
    Instruction op = *it;

    if ((op.opcode == spv::OpName || op.opcode == spv::OpDecorate || op.opcode == spv::OpMemberName || op.opcode == spv::OpMemberDecorate) &&
        op.nargs >= 2 && deleted_ids.count(op.args[0])) {
      _instructions.erase(it);
      continue;
    }

    ++it;
  }
}

/**
 * Creates a new uniform block using the parameters specified by the given
 * locations and types.  The opposite of flatten_struct, if you will.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
make_block(const ShaderType::Struct *block_type, const pvector<int> &member_locations,
           spv::StorageClass storage_class, uint32_t binding, uint32_t set) {
  nassertr(block_type->get_num_members() == member_locations.size(), false);

  // Define block struct variable, which will implicitly define its type.
  uint32_t block_var_id = define_variable(block_type, storage_class);
  uint32_t block_type_id = _type_map[block_type];
  nassertr(block_type_id != 0, 0);

  // Collect type pointers that we have to create.
  pvector<uint32_t> insert_type_pointers;

  // Find the variables we should replace with members of this block by looking
  // at the at the locations.  Collect a map of defined type pointers while
  // we're at it, so we don't unnecessarily duplicate them.
  pmap<uint32_t, uint32_t> member_indices;
  pmap<uint32_t, uint32_t> type_pointer_map;

  for (uint32_t id = 0; id < _defs.size(); ++id) {
    Definition &def = _defs[id];
    if (def._dtype == DT_type_pointer) {
      if (!def.has_builtin() && def._storage_class == storage_class) {
        // This is the storage class we need, store it in case we need it.
        type_pointer_map[def._type_id] = id;
      }
    }
    else if (def._dtype == DT_variable && def._location >= 0 &&
             def._storage_class == spv::StorageClassUniformConstant) {

      auto lit = std::find(member_locations.begin(), member_locations.end(), def._location);
      if (lit != member_locations.end()) {
        member_indices[id] = std::distance(member_locations.begin(), lit);
      }
    }
  }

  uint32_t num_members = member_locations.size();
  uint32_t *allocation = (uint32_t *)alloca(num_members * sizeof(uint32_t) * 2);
  memset(allocation, 0, num_members * sizeof(uint32_t) * 2);

  uint32_t *member_type_ids = allocation;
  uint32_t *member_constant_ids = allocation + num_members;

  // Now add the decorations for the uniform block itself.
  InstructionIterator it = _instructions.end_annotations();
  it = _instructions.insert(it, spv::OpDecorate, {block_type_id, spv::DecorationBlock});
  ++it;

  if (storage_class != spv::StorageClassPushConstant) {
    it = _instructions.insert(it, spv::OpDecorate, {block_var_id, spv::DecorationBinding, binding});
    ++it;
    it = _instructions.insert(it, spv::OpDecorate, {block_var_id, spv::DecorationDescriptorSet, set});
    ++it;
  }

  it = _instructions.begin();
  while (it != _instructions.end()) {
    Instruction op = *it;

    switch (op.opcode) {
    case spv::OpName:
      // Translate an OpName to an OpMemberName for vars that become struct
      // members.  We could just strip them, but this is useful for debugging.
      if (member_indices.count(op.args[0])) {
        uint32_t member_index = member_indices[op.args[0]];

        uint32_t nargs = op.nargs + 1;
        uint32_t *args = (uint32_t *)alloca(nargs * sizeof(uint32_t));
        args[0] = block_type_id;
        args[1] = member_index;
        memcpy(args + 2, op.args + 1, (op.nargs - 1) * sizeof(uint32_t));

        it = _instructions.insert(it, spv::OpMemberName, args, nargs);
        ++it;
        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpMemberName:
    case spv::OpDecorate:
    case spv::OpMemberDecorate:
      // Remove other annotations on the members.
      if (op.nargs >= 1 && member_indices.count(op.args[0])) {
        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpConstant:
      // Store integer constants that are already defined in the file that may
      // be useful for defining our struct indices.
      if (op.args[2] < num_members &&
          (_defs[op.args[0]]._type == ShaderType::int_type || _defs[op.args[0]]._type == ShaderType::uint_type)) {
        member_constant_ids[op.args[2]] = op.args[1];
      }
      break;

    case spv::OpVariable:
      if (member_indices.count(op.args[1])) {
        // Remove this variable.  We'll replace it with an access chain later.
        uint32_t type_pointer_id = op.args[0];
        uint32_t member_id = op.args[1];
        uint32_t member_index = member_indices[member_id];

        if (_defs[type_pointer_id]._storage_class != storage_class) {
          // Get or create a type pointer with the correct storage class.
          uint32_t type_id = _defs[type_pointer_id]._type_id;
          auto tpi = type_pointer_map.find(type_id);
          if (tpi != type_pointer_map.end()) {
            type_pointer_id = tpi->second;
          } else {
            type_pointer_id = _instructions.allocate_id();
            type_pointer_map[type_id] = type_pointer_id;
            record_type_pointer(type_pointer_id, storage_class, type_id);

            it = _instructions.insert(it, spv::OpTypePointer,
              {type_pointer_id, (uint32_t)storage_class, type_id});
            ++it;
          }
        }

        member_type_ids[member_index] = type_pointer_id;

        it = _instructions.erase(it);
        continue;
      }
      break;

    case spv::OpFunction:
      // Before we get to the function section, make sure that all the
      // remaining constants we need are defined.
      for (uint32_t i =  0; i < num_members; ++i) {
        uint32_t constant_id = member_constant_ids[i];
        if (constant_id == 0) {
          // Doesn't matter whether we pick uint or int, prefer whatever is
          // already defined.
          const ShaderType *type =
            _type_map.count(ShaderType::uint_type)
              ? ShaderType::uint_type
              : ShaderType::int_type;
          constant_id = r_define_constant(it, type, i);
          member_constant_ids[i] = constant_id;
        }
      }
      break;

    case spv::OpAccessChain:
    case spv::OpInBoundsAccessChain:
      if (member_indices.count(op.args[2])) {
        uint32_t member_index = member_indices[op.args[2]];
        uint32_t constant_id = member_constant_ids[member_index];

        // Get or create a type pointer with the correct storage class.
        uint32_t type_id = _defs[op.args[0]]._type_id;
        auto tpi = type_pointer_map.find(type_id);
        uint32_t type_pointer_id;
        if (tpi != type_pointer_map.end()) {
          type_pointer_id = tpi->second;
        } else {
          type_pointer_id = _instructions.allocate_id();
          type_pointer_map[type_id] = type_pointer_id;
          record_type_pointer(type_pointer_id, storage_class, type_id);

          // Can't create the type pointer immediately, since we're no longer
          // in the type declaration block.  We'll add it at the end.
          insert_type_pointers.push_back(type_pointer_id);
        }
        op.args[0] = type_pointer_id;

        // Prepend our new block variable to the existing access chain.
        op.args[2] = block_var_id;
        it = _instructions.insert_arg(it, 3, constant_id);
      }
      break;

    case spv::OpImageTexelPointer:
    case spv::OpLoad:
    case spv::OpCopyObject:
      // Add access chains before all loads to access the right block member.
      if (member_indices.count(op.args[2])) {
        uint32_t member_index = member_indices[op.args[2]];
        uint32_t type_id = member_type_ids[member_index];
        uint32_t constant_id = member_constant_ids[member_index];
        uint32_t chain_id = _instructions.allocate_id();

        op.args[2] = chain_id;
        it = _instructions.insert(it, spv::OpInBoundsAccessChain,
          {type_id, chain_id, block_var_id, constant_id});
        ++it;
      }
      break;

    case spv::OpCopyMemory:
    case spv::OpCopyMemorySized:
      // Same as above, but these take the pointer in a different argument.
      if (member_indices.count(op.args[1])) {
        uint32_t member_index = member_indices[op.args[1]];
        uint32_t type_id = member_type_ids[member_index];
        uint32_t constant_id = member_constant_ids[member_index];
        uint32_t chain_id = _instructions.allocate_id();

        op.args[1] = chain_id;
        it = _instructions.insert(it, spv::OpInBoundsAccessChain,
          {type_id, chain_id, block_var_id, constant_id});
        ++it;
      }
      break;

    default:
      break;
    }

    ++it;
  }

  it = _instructions.begin_functions();

  // Insert all the type pointers for the access chains.
  for (uint32_t id : insert_type_pointers) {
    it = _instructions.insert(it, spv::OpTypePointer,
      {id, (uint32_t)_defs[id]._storage_class, _defs[id]._type_id});
    ++it;
  }

  return block_var_id;
}

/**
 * Defines a new variable of the given type and storage class.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
define_variable(const ShaderType *type, spv::StorageClass storage_class) {
  InstructionIterator it = _instructions.begin_functions();
  uint32_t id = r_define_variable(it, type, storage_class);

  // Depending on the storage class, we may need to make sure it is laid out.
  if (storage_class == spv::StorageClassStorageBuffer ||
      storage_class == spv::StorageClassPhysicalStorageBuffer ||
      storage_class == spv::StorageClassUniform ||
      storage_class == spv::StorageClassPushConstant) {
    it = _instructions.end_annotations();
    r_annotate_struct_layout(it, _type_map[type]);
  }

  return id;
}

/**
 * Makes sure the given type pointer is defined.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
define_type_pointer(const ShaderType *type, spv::StorageClass storage_class) {
  InstructionIterator it = _instructions.begin_functions();
  uint32_t type_id = r_define_type(it, type);
  uint32_t type_pointer_id = _instructions.allocate_id();

  record_type_pointer(type_pointer_id, storage_class, type_id);
  _instructions.insert(it, spv::OpTypePointer,
    {type_pointer_id, (uint32_t)storage_class, type_id});

  // Depending on the storage class, we may need to make sure it is laid out.
  if (storage_class == spv::StorageClassStorageBuffer ||
      storage_class == spv::StorageClassPhysicalStorageBuffer ||
      storage_class == spv::StorageClassUniform ||
      storage_class == spv::StorageClassPushConstant) {
    it = _instructions.end_annotations();
    r_annotate_struct_layout(it, type_id);
  }

  return type_pointer_id;
}

/**
 * Makes sure the given type is defined.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
define_type(const ShaderType *type) {
  InstructionIterator it = _instructions.begin_functions();
  return r_define_type(it, type);
}

/**
 * Defines a new constant of the given type and value.  If the type has not yet
 * been defined, defines it.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
define_constant(const ShaderType *type, uint32_t constant) {
  InstructionIterator it = _instructions.begin_functions();
  return r_define_constant(it, type, constant);
}

/**
 * Helper for define_variable that inserts a variable at the iterator, and then
 * advances the iterator.
 *
 * Note that unlike define_variable(), it does not ensure that any struct type
 * has been sufficiently laid out for this storage class.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
r_define_variable(InstructionIterator &it, const ShaderType *type, spv::StorageClass storage_class) {
  uint32_t type_pointer_id = r_define_type_pointer(it, type, storage_class);

  uint32_t variable_id = _instructions.allocate_id();
  it = _instructions.insert(it, spv::OpVariable, {
    type_pointer_id,
    variable_id,
    (uint32_t)storage_class,
  });
  ++it;

  record_variable(variable_id, type_pointer_id, storage_class);
  return variable_id;
}

/**
 * Helper for define_type_pointer that inserts a type pointer at the iterator
 * (though only if this type pointer doesn't exist yet), then advances the
 * iterator.
 *
 * Note that unlike define_type_pointer(), it does not ensure that any struct
 * type has been sufficiently laid out for this storage class.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
r_define_type_pointer(InstructionIterator &it, const ShaderType *type, spv::StorageClass storage_class) {
  uint32_t type_id;
  TypeMap::const_iterator tit = _type_map.find(type);
  if (tit != _type_map.end()) {
    type_id = tit->second;

    // Do we already have a type pointer for this type?
    for (uint32_t id = 0; id < _defs.size(); ++id) {
      Definition &def = _defs[id];
      if (def._dtype == DT_type_pointer &&
          def._type_id == type_id &&
          def._storage_class == storage_class) {
        // Already defined.
        return id;
      }
    }
  } else {
    type_id = r_define_type(it, type);
  }

  uint32_t type_pointer_id = _instructions.allocate_id();
  record_type_pointer(type_pointer_id, storage_class, type_id);

  _instructions.insert(it, spv::OpTypePointer,
    {type_pointer_id, (uint32_t)storage_class, type_id});
  ++it;

  return type_pointer_id;
}

/**
 * Helper for define_type.  Inserts the given type (after any requisite
 * dependent types, as found through the given type map) at the given iterator,
 * and advances the iterator.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
r_define_type(InstructionIterator &it, const ShaderType *type) {
  TypeMap::const_iterator tit = _type_map.find(type);
  if (tit != _type_map.end()) {
    return tit->second;
  }

  uint32_t id = _instructions.allocate_id();
  record_type(id, type);

  if (const ShaderType::Scalar *scalar_type = type->as_scalar()) {
    switch (scalar_type->get_scalar_type()) {
    case ShaderType::ST_float:
      it = _instructions.insert(it, spv::OpTypeFloat, {id, 32});
      break;
    case ShaderType::ST_double:
      it = _instructions.insert(it, spv::OpTypeFloat, {id, 64});
      break;
    case ShaderType::ST_int:
      it = _instructions.insert(it, spv::OpTypeInt, {id, 32, 1});
      break;
    case ShaderType::ST_uint:
      it = _instructions.insert(it, spv::OpTypeInt, {id, 32, 0});
      break;
    case ShaderType::ST_bool:
      it = _instructions.insert(it, spv::OpTypeBool, {id});
      break;
    default:
      it = _instructions.insert(it, spv::OpTypeVoid, {id});
      break;
    }
  }
  else if (const ShaderType::Vector *vector_type = type->as_vector()) {
    uint32_t component_type = r_define_type(it,
      ShaderType::register_type(ShaderType::Scalar(vector_type->get_scalar_type())));

    it = _instructions.insert(it, spv::OpTypeVector,
      {id, component_type, vector_type->get_num_components()});
  }
  else if (const ShaderType::Matrix *matrix_type = type->as_matrix()) {
    uint32_t row_type = r_define_type(it,
      ShaderType::register_type(ShaderType::Vector(matrix_type->get_scalar_type(), matrix_type->get_num_columns())));

    it = _instructions.insert(it, spv::OpTypeMatrix,
      {id, row_type, matrix_type->get_num_rows()});
  }
  else if (const ShaderType::Struct *struct_type = type->as_struct()) {
    size_t num_members = struct_type->get_num_members();
    uint32_t *args = (uint32_t *)alloca((1 + num_members) * sizeof(uint32_t));
    args[0] = id;
    uint32_t *member_types = args + 1;

    for (size_t i = 0; i < num_members; ++i) {
      const ShaderType::Struct::Member &member = struct_type->get_member(i);

      member_types[i] = r_define_type(it, member.type);
      _defs[id].modify_member(i)._type_id = member_types[i];
    }

    it = _instructions.insert(it, spv::OpTypeStruct, args, num_members + 1);
  }
  else if (const ShaderType::Array *array_type = type->as_array()) {
    uint32_t element_type = r_define_type(it, array_type->get_element_type());
    it = _instructions.insert(it, spv::OpTypeArray,
      {id, element_type, array_type->get_num_elements()});
  }
  else if (const ShaderType::Image *image_type = type->as_image()) {
    uint32_t args[9] = {
      id,
      r_define_type(it, ShaderType::register_type(ShaderType::Scalar(image_type->get_sampled_type()))),
      0, // Dimensionality, see below
      2, // Unspecified depthness
      0, // Arrayness, see below
      0, // Multisample not supported
      0, // Sampled (unknown)
      spv::ImageFormatUnknown,
      0, // Access qualifier
    };

    switch (image_type->get_texture_type()) {
    case Texture::TT_1d_texture:
      args[2] = spv::Dim1D;
      args[4] = 0;
      break;
    case Texture::TT_2d_texture:
      args[2] = spv::Dim2D;
      args[4] = 0;
      break;
    case Texture::TT_3d_texture:
      args[2] = spv::Dim3D;
      args[4] = 0;
      break;
    case Texture::TT_2d_texture_array:
      args[2] = spv::Dim2D;
      args[4] = 1;
      break;
    case Texture::TT_cube_map:
      args[2] = spv::DimCube;
      args[4] = 0;
      break;
    case Texture::TT_buffer_texture:
      args[2] = spv::DimBuffer;
      args[4] = 0;
      break;
    case Texture::TT_cube_map_array:
      args[2] = spv::DimCube;
      args[4] = 1;
      break;
    case Texture::TT_1d_texture_array:
      args[2] = spv::Dim1D;
      args[4] = 1;
      break;
    }

    uint32_t nargs = 8;
    switch (image_type->get_access()) {
    case ShaderType::Image::Access::unknown:
      break;
    case ShaderType::Image::Access::read_only:
      args[8] = spv::AccessQualifierReadOnly;
      ++nargs;
      break;
    case ShaderType::Image::Access::write_only:
      args[8] = spv::AccessQualifierWriteOnly;
      ++nargs;
      break;
    case ShaderType::Image::Access::read_write:
      args[8] = spv::AccessQualifierReadWrite;
      ++nargs;
      break;
    }

    it = _instructions.insert(it, spv::OpTypeImage, args, nargs);
  }
  else if (const ShaderType::Sampler *sampler_type = type->as_sampler()) {
    it = _instructions.insert(it, spv::OpTypeSampler, {id});
  }
  else if (const ShaderType::SampledImage *sampled_image_type = type->as_sampled_image()) {
    uint32_t image_type = r_define_type(it,
      ShaderType::register_type(ShaderType::Image(sampled_image_type->get_texture_type(), sampled_image_type->get_sampled_type(), ShaderType::Image::Access::unknown)));

    it = _instructions.insert(it, spv::OpTypeSampledImage, {id, image_type});
  }
  else {
    it = _instructions.insert(it, spv::OpTypeVoid, {id});
  }

  ++it;
  return id;
}

/**
 * Helper for define_constant that inserts a variable at the iterator, and then
 * advances the iterator.
 */
uint32_t ShaderModuleSpirV::InstructionWriter::
r_define_constant(InstructionIterator &it, const ShaderType *type, uint32_t constant) {
  uint32_t type_id = r_define_type(it, type);

  uint32_t constant_id = _instructions.allocate_id();
  it = _instructions.insert(it, spv::OpConstant, {type_id, constant_id, constant});
  ++it;

  record_constant(constant_id, type_id, &constant, 1);
  return constant_id;
}

/**
 * Makes sure that the given type has all its structure members correctly laid
 * out using offsets and strides.
 */
void ShaderModuleSpirV::InstructionWriter::
r_annotate_struct_layout(InstructionIterator &it, uint32_t type_id) {
  const ShaderType *type = _defs[type_id]._type;
  nassertv(type != nullptr);

  const ShaderType::Struct *struct_type = type->as_struct();
  if (struct_type == nullptr) {
    return;
  }

  uint32_t num_members = struct_type->get_num_members();

  for (uint32_t i = 0; i < num_members; ++i) {
    const ShaderType::Struct::Member &member = struct_type->get_member(i);

    MemberDefinition &member_def = _defs[type_id].modify_member(i);
    if (member_def._offset < 0) {
      member_def._offset = member.offset;

      it = _instructions.insert(it, spv::OpMemberDecorate,
        {type_id, i, spv::DecorationOffset, member.offset});
      ++it;
    }

    // Unwrap array to see if there's a matrix here.
    const ShaderType *base_type = member.type;
    while (const ShaderType::Array *array_type = base_type->as_array()) {
      base_type = array_type->get_element_type();

      // Also make sure there's an ArrayStride decoration for this array.
      uint32_t array_type_id = _type_map[array_type];
      Definition &array_def = _defs[array_type_id];

      if (array_def._array_stride == 0) {
        array_def._array_stride = array_type->get_stride_bytes();
        it = _instructions.insert(it, spv::OpDecorate,
          {array_type_id, spv::DecorationArrayStride, array_def._array_stride});
        ++it;
      }
    }

    if (const ShaderType::Matrix *matrix_type = base_type->as_matrix()) {
      // Matrix types need to be explicitly laid out.
      it = _instructions.insert(it, spv::OpMemberDecorate,
        {type_id, i, spv::DecorationMatrixStride, matrix_type->get_num_columns() * 4});
      ++it;
      it = _instructions.insert(it, spv::OpMemberDecorate,
        {type_id, i, spv::DecorationColMajor});
      ++it;
    } else {
      r_annotate_struct_layout(it, member_def._type_id);
    }
  }
}

/**
 * Parses the instruction with the given SPIR-V opcode and arguments.  Any
 * encountered definitions are recorded in the definitions vector.
 */
void ShaderModuleSpirV::InstructionWriter::
parse_instruction(const Instruction &op) {
  switch (op.opcode) {
  case spv::OpExtInstImport:
    record_ext_inst_import(op.args[0], (const char*)&op.args[1]);
    break;

  case spv::OpName:
    _defs[op.args[0]]._name.assign((const char *)&op.args[1]);
    break;

  case spv::OpMemberName:
    _defs[op.args[0]].modify_member(op.args[1])._name.assign((const char *)&op.args[2]);
    break;

  case spv::OpTypeVoid:
    record_type(op.args[0], nullptr);
    break;

  case spv::OpTypeBool:
    record_type(op.args[0], ShaderType::bool_type);
    break;

  case spv::OpTypeInt:
    {
      if (op.args[2]) {
        record_type(op.args[0], ShaderType::int_type);
      } else {
        record_type(op.args[0], ShaderType::uint_type);
      }
    }
    break;

  case spv::OpTypeFloat:
    {
      if (op.nargs >= 2 && op.args[1] >= 64) {
        record_type(op.args[0], ShaderType::double_type);
      } else {
        record_type(op.args[0], ShaderType::float_type);
      }
    }
    break;

  case spv::OpTypeVector:
    {
      const ShaderType::Scalar *element_type;
      DCAST_INTO_V(element_type, _defs[op.args[1]]._type);
      uint32_t component_count = op.args[2];
      record_type(op.args[0], ShaderType::register_type(
        ShaderType::Vector(element_type->get_scalar_type(), component_count)));
    }
    break;

  case spv::OpTypeMatrix:
    {
      const ShaderType::Vector *column_type;
      DCAST_INTO_V(column_type, _defs[op.args[1]]._type);
      uint32_t num_rows = op.args[2];
      record_type(op.args[0], ShaderType::register_type(
        ShaderType::Matrix(column_type->get_scalar_type(), num_rows, column_type->get_num_components())));
    }
    break;

  case spv::OpTypePointer:
    record_type_pointer(op.args[0], (spv::StorageClass)op.args[1], op.args[2]);
    break;

  case spv::OpTypeImage:
    {
      const ShaderType::Scalar *sampled_type;
      DCAST_INTO_V(sampled_type, _defs[op.args[1]]._type);

      Texture::TextureType texture_type;
      switch ((spv::Dim)op.args[2]) {
      case spv::Dim1D:
        if (op.args[4]) {
          texture_type = Texture::TT_1d_texture_array;
        } else {
          texture_type = Texture::TT_1d_texture;
        }
        break;

      case spv::Dim2D:
        if (op.args[4]) {
          texture_type = Texture::TT_2d_texture_array;
        } else {
          texture_type = Texture::TT_2d_texture;
        }
        break;

      case spv::Dim3D:
        texture_type = Texture::TT_3d_texture;
        break;

      case spv::DimCube:
        if (op.args[4]) {
          texture_type = Texture::TT_cube_map_array;
        } else {
          texture_type = Texture::TT_cube_map;
        }
        break;

      case spv::DimRect:
        shader_cat.error()
          << "imageRect shader inputs are not supported.\n";
        return;

      case spv::DimBuffer:
        texture_type = Texture::TT_buffer_texture;
        break;

      case spv::DimSubpassData:
        shader_cat.error()
          << "subpassInput shader inputs are not supported.\n";
        return;

      default:
        shader_cat.error()
          << "Unknown image dimensionality in OpTypeImage instruction.\n";
        return;
      }

      ShaderType::Image::Access access = ShaderType::Image::Access::unknown;
      if (op.nargs > 8) {
        switch ((spv::AccessQualifier)op.args[8]) {
        case spv::AccessQualifierReadOnly:
          access = ShaderType::Image::Access::read_only;
          break;
        case spv::AccessQualifierWriteOnly:
          access = ShaderType::Image::Access::write_only;
          break;
        case spv::AccessQualifierReadWrite:
          access = ShaderType::Image::Access::read_write;
          break;
        default:
          shader_cat.error()
            << "Invalid access qualifier in OpTypeImage instruction.\n";
          break;
        }
      }

      record_type(op.args[0], ShaderType::register_type(
        ShaderType::Image(texture_type, sampled_type->get_scalar_type(), access)));
    }
    break;

  case spv::OpTypeSampler:
    // A sampler that's not bound to a particular image.
    record_type(op.args[0], ShaderType::sampler_type);
    break;

  case spv::OpTypeSampledImage:
    if (const ShaderType::Image *image = _defs[op.args[1]]._type->as_image()) {
      record_type(op.args[0], ShaderType::register_type(
        ShaderType::SampledImage(image->get_texture_type(), image->get_sampled_type())));
    } else {
      shader_cat.error()
        << "OpTypeSampledImage must refer to an image type!\n";
      return;
    }
    break;

  case spv::OpTypeArray:
    if (_defs[op.args[1]]._type != nullptr) {
      record_type(op.args[0], ShaderType::register_type(
        ShaderType::Array(_defs[op.args[1]]._type, _defs[op.args[2]]._constant)));
    }
    break;

  case spv::OpTypeStruct:
    {
      Definition &struct_def = _defs[op.args[0]];
      ShaderType::Struct type;
      for (size_t i = 0; i < op.nargs - 1; ++i) {
        uint32_t member_type_id = op.args[i + 1];
        if (member_type_id >= _defs.size() || _defs[member_type_id]._dtype != DT_type) {
          shader_cat.error()
            << "Struct type with id " << op.args[0]
            << " contains invalid member type " << member_type_id << "\n";
          return;
        }

        MemberDefinition &member_def = struct_def.modify_member(i);
        member_def._type_id = member_type_id;
        if (member_def._builtin != spv::BuiltInMax) {
          // Ignore built-in member.
          continue;
        }
        if (member_def._offset >= 0) {
          type.add_member(_defs[member_type_id]._type, member_def._name, (uint32_t)member_def._offset);
        } else {
          type.add_member(_defs[member_type_id]._type, member_def._name);
        }
      }
      record_type(op.args[0], ShaderType::register_type(std::move(type)));
    }
    break;

  case spv::OpConstant:
    record_constant(op.args[1], op.args[0], op.args + 2, op.nargs - 2);
    break;

  case spv::OpFunctionCall:
    // Mark all arguments as used.
    for (size_t i = 3; i < op.nargs; ++i) {
      _defs[op.args[i]]._used = true;
    }
    break;

  case spv::OpVariable:
    record_variable(op.args[1], op.args[0], (spv::StorageClass)op.args[2]);
    break;

  case spv::OpImageTexelPointer:
  case spv::OpLoad:
  case spv::OpAccessChain:
  case spv::OpInBoundsAccessChain:
  case spv::OpPtrAccessChain:
  case spv::OpCopyObject:
  case spv::OpAtomicLoad:
  case spv::OpAtomicExchange:
  case spv::OpAtomicCompareExchange:
  case spv::OpAtomicCompareExchangeWeak:
  case spv::OpAtomicIIncrement:
  case spv::OpAtomicIDecrement:
  case spv::OpAtomicIAdd:
  case spv::OpAtomicISub:
  case spv::OpAtomicSMin:
  case spv::OpAtomicUMin:
  case spv::OpAtomicSMax:
  case spv::OpAtomicUMax:
  case spv::OpAtomicAnd:
  case spv::OpAtomicOr:
  case spv::OpAtomicXor:
  case spv::OpAtomicFlagTestAndSet:
    _defs[op.args[2]]._used = true;
    break;

  case spv::OpCopyMemory:
  case spv::OpCopyMemorySized:
    _defs[op.args[1]]._used = true;
    break;

  case spv::OpDecorate:
    switch ((spv::Decoration)op.args[1]) {
    case spv::DecorationBuiltIn:
      _defs[op.args[0]]._builtin = (spv::BuiltIn)op.args[2];
      break;

    case spv::DecorationLocation:
      _defs[op.args[0]]._location = op.args[2];
      break;

    case spv::DecorationArrayStride:
      _defs[op.args[0]]._array_stride = op.args[2];
      break;

    default:
      break;
    }
    break;

  case spv::OpMemberDecorate:
    switch ((spv::Decoration)op.args[2]) {
    case spv::DecorationBuiltIn:
      _defs[op.args[0]].modify_member(op.args[1])._builtin = (spv::BuiltIn)op.args[3];
      break;

    case spv::DecorationOffset:
      _defs[op.args[0]].modify_member(op.args[1])._offset = (spv::BuiltIn)op.args[3];
      break;

    default:
      break;
    }
    break;

  default:
    break;
  }
}

/**
 * Records that the given type has been defined.
 */
void ShaderModuleSpirV::InstructionWriter::
record_type(uint32_t id, const ShaderType *type) {
  Definition &def = modify_definition(id);
  def._dtype = DT_type;
  def._type = type;

  if (shader_cat.is_spam()) {
    if (type != nullptr) {
      shader_cat.spam()
        << "Defined type " << id << ": " << *type << "\n";
    } else {
      shader_cat.spam()
        << "Defined type " << id << ": void\n";
    }
  }

  if (!def.has_builtin()) {
    // Only put types we can fully round-trip in the type map.
    _type_map[type] = id;
  }
}

/**
 * Records that the given type pointer has been defined.
 */
void ShaderModuleSpirV::InstructionWriter::
record_type_pointer(uint32_t id, spv::StorageClass storage_class, uint32_t type_id) {
  const Definition &type_def = get_definition(type_id);
  nassertv(type_def._dtype == DT_type || type_def._dtype == DT_type_pointer);

  Definition &def = modify_definition(id);
  def._dtype = DT_type_pointer;
  def._type = type_def._type;
  def._storage_class = storage_class;
  def._type_id = type_id;
}

/**
 * Records that the given variable has been defined.
 */
void ShaderModuleSpirV::InstructionWriter::
record_variable(uint32_t id, uint32_t type_pointer_id, spv::StorageClass storage_class) {
  const Definition &type_pointer_def = get_definition(type_pointer_id);
  if (type_pointer_def._dtype != DT_type_pointer && type_pointer_def._type_id != 0) {
    shader_cat.error()
      << "Variable " << id << " should have valid pointer type\n";
    return;
  }

  const Definition &type_def = get_definition(type_pointer_def._type_id);
  if (type_def._dtype != DT_type) {
    shader_cat.error()
      << "Type pointer " << type_pointer_id << " should point to valid type "
         "for variable " << id << "\n";
    return;
  }

  Definition &def = modify_definition(id);
  def._dtype = DT_variable;
  def._type = type_def._type;
  def._storage_class = storage_class;

  if (shader_cat.is_debug() && storage_class == spv::StorageClassUniformConstant) {
    shader_cat.debug()
      << "Defined uniform " << id << ": " << def._name;

    if (def._location >= 0) {
      shader_cat.debug(false) << " (location " << def._location << ")";
    }

    shader_cat.debug(false) << " with ";

    if (def._type != nullptr) {
      shader_cat.debug(false) << "type " << *def._type << "\n";
    } else {
      shader_cat.debug(false) << "unknown type\n";
    }
  }
}

/**
 * Records that the given constant has been defined.
 */
void ShaderModuleSpirV::InstructionWriter::
record_constant(uint32_t id, uint32_t type_id, const uint32_t *words, uint32_t nwords) {
  const Definition &type_def = get_definition(type_id);
  nassertv(type_def._dtype == DT_type);

  Definition &def = modify_definition(id);
  def._dtype = DT_constant;
  def._type_id = type_id;
  def._type = type_def._type;
  if (nwords > 0) {
    def._constant = words[0];
  } else {
    def._constant = 0;
  }
}

/**
 * Records an external import.
 */
void ShaderModuleSpirV::InstructionWriter::
record_ext_inst_import(uint32_t id, const char *import) {
  Definition &def = modify_definition(id);
  def._dtype = DT_ext_inst;
  def._name.assign(import);
}
