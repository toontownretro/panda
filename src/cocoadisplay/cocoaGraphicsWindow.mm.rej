diff a/panda/src/cocoadisplay/cocoaGraphicsWindow.mm b/panda/src/cocoadisplay/cocoaGraphicsWindow.mm	(rejected hunks)
@@ -161,152 +159,6 @@
   return false;
 }
 
-
-/**
- * This function will be called within the draw thread before beginning
- * rendering for a given frame.  It should do whatever setup is required, and
- * return true if the frame should be rendered, or false if it should be
- * skipped.
- */
-bool CocoaGraphicsWindow::
-begin_frame(FrameMode mode, Thread *current_thread) {
-  PStatTimer timer(_make_current_pcollector, current_thread);
-
-  begin_frame_spam(mode);
-  if (_gsg == (GraphicsStateGuardian *)NULL) {
-    return false;
-  }
-
-  CocoaGraphicsStateGuardian *cocoagsg;
-  DCAST_INTO_R(cocoagsg, _gsg, false);
-  nassertr(cocoagsg->_context != nil, false);
-  nassertr(_view != nil, false);
-
-  // Place a lock on the context.
-  cocoagsg->lock_context();
-
-  // Set the drawable.
-  // Although not recommended, it is technically possible to use the same
-  // context with multiple different-sized windows.  If that happens, the
-  // context needs to be updated accordingly.
-  if ([cocoagsg->_context view] != _view) {
-    // XXX I'm not 100% sure that changing the view requires it to update.
-    _context_needs_update = true;
-    [cocoagsg->_context setView:_view];
-
-    if (cocoadisplay_cat.is_spam()) {
-      cocoadisplay_cat.spam()
-        << "Switching context to view " << _view << "\n";
-    }
-  }
-
-  // Update the context if necessary, to make it reallocate buffers etc.
-  if (_context_needs_update) {
-    if ([NSThread isMainThread]) {
-      [cocoagsg->_context update];
-      _context_needs_update = false;
-    } else {
-      cocoagsg->unlock_context();
-      return false;
-    }
-  }
-
-  // Lock the view for drawing.
-  if (!_properties.get_fullscreen()) {
-    nassertr_always([_view lockFocusIfCanDraw], false);
-  }
-
-  // Make the context current.
-  [cocoagsg->_context makeCurrentContext];
-
-  // Now that we have made the context current to a window, we can reset the
-  // GSG state if this is the first time it has been used.  (We can't just
-  // call reset() when we construct the GSG, because reset() requires having a
-  // current context.)
-  cocoagsg->reset_if_new();
-
-  if (mode == FM_render) {
-    // begin_render_texture();
-    clear_cube_map_selection();
-  }
-
-  _gsg->set_current_properties(&get_fb_properties());
-  if (_gsg->begin_frame(current_thread)) {
-    copy_async_screenshot();
-    return true;
-  } else {
-    return false;
-  }
-}
-
-/**
- * This function will be called within the draw thread after rendering is
- * completed for a given frame.  It should do whatever finalization is
- * required.
- */
-void CocoaGraphicsWindow::
-end_frame(FrameMode mode, Thread *current_thread) {
-  end_frame_spam(mode);
-  nassertv(_gsg != (GraphicsStateGuardian *)NULL);
-
-  if (!_properties.get_fullscreen()) {
-    [_view unlockFocus];
-  }
-  // Release the context.
-  CocoaGraphicsStateGuardian *cocoagsg;
-  DCAST_INTO_V(cocoagsg, _gsg);
-
-  cocoagsg->unlock_context();
-
-  if (mode == FM_render) {
-    // end_render_texture();
-    copy_to_textures();
-  }
-
-  _gsg->end_frame(current_thread);
-
-  if (mode == FM_render) {
-    trigger_flip();
-    clear_cube_map_selection();
-  }
-}
-
-/**
- * This function will be called within the draw thread after begin_flip() has
- * been called on all windows, to finish the exchange of the front and back
- * buffers.
- *
- * This should cause the window to wait for the flip, if necessary.
- */
-void CocoaGraphicsWindow::
-end_flip() {
-  if (_gsg != (GraphicsStateGuardian *)NULL && _flip_ready) {
-
-    CocoaGraphicsStateGuardian *cocoagsg;
-    DCAST_INTO_V(cocoagsg, _gsg);
-
-    if (_vsync_enabled) {
-      AtomicAdjust::Integer cur_frame = ClockObject::get_global_clock()->get_frame_count();
-      if (AtomicAdjust::set(cocoagsg->_last_wait_frame, cur_frame) != cur_frame) {
-        cocoagsg->_swap_lock.lock();
-        cocoagsg->_swap_condition.wait();
-        cocoagsg->_swap_lock.unlock();
-      }
-    }
-
-    cocoagsg->lock_context();
-
-    // Swap the front and back buffer.
-    [cocoagsg->_context flushBuffer];
-
-    // Flush the window
-    [[_view window] flushWindow];
-
-    cocoagsg->unlock_context();
-  }
-  GraphicsWindow::end_flip();
-}
-
 /**
  * Do whatever processing is necessary to ensure that the window responds to
  * user events.  Also, honor any requests recently made via
